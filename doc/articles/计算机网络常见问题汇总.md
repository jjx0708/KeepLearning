## 计网面经整理

### 1. TCP/IP

OSI的七层协议体系结构的概念清楚，理论也比较完整，但它既复杂又不实用。

ICP/IP体系结构则不同，它现在已经得到了非常广泛的应用，TCP/IP是一个四层的体系结构，它包含应用层、运输层、网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题）。

不过从实质来讲，TCP/IP只有最上面的三层，因为最下面的网络接口层基本上和一般的通信链路的功能上没有多大差别，对于计算机网络来说，这一层并没有什么特别新的具体的内容，因此在学习计算机网络原理是往往采用折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190612232845989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlZmZpbg==,size_16,color_FFFFFF,t_70)



- 应用层:提供用户与网络间的接口。
  - RIP、DNS、DHCP、SNMP、TFTP
  - SMTP、HTTP、HTTPS、FTP
- 运输层:进程到进程间的数据传输。
  - TCP、UDP
- 网络层:主机到主机之间的数据传输
  - IP、路由协议
- 数据链路层:相邻结点之间的数据传输。
  - PPP、以太网
- 物理层:在物理介质上传输比特流。

### 2.  OSI七层模型

##### 1). 物理层

参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。

##### 2). 数据链路层（data link layer）

接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。

##### 3). 网络层

将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613235712647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlZmZpbg==,size_16,color_FFFFFF,t_70)

##### 4). 传输层（transport layer）

在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190613235731347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlZmZpbg==,size_16,color_FFFFFF,t_70)
实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。

##### 5). 会话层（Session Layer）

会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。

##### 6). 表示层（Presentation Layer）：

数据的编码，压缩和解压缩，数据的加密和解密

表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

##### 7). 应用层（Application layer）：

为用户的应用进程提供网络通信服务

### 3. Http和Https的区别

Http 和 https 协议都是运行在TCP之上，不过 http 是明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。

二者之间存在如下不同：

- 端口不同：Http与Https使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
- 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
- 开销：Https通信需要证书，而证书一般需要向认证机构购买；

Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

### 4. 对称加密与非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；

而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；

但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

### 5. 三次握手

1. 首先服务器先开启监听；
2. 客户端主动打开连接，向服务器发送请求同步的标志位 SYN = 1，并告诉服务端即将发送的序列为 seq = x，进入同步已发送状态；
3. 服务端收到客户端请求建立连接的报文，进入同步已接收状态，并向客户端发送 SYN = 1，ACK = 1，表示确认请求，ack = x+1 表示对客户端请求发送序列的确认，表示接下来需要接收 x+1 序列，seq = y 表示服务端这边即将发送序列为 y ；
4. 客户端收到服务端返回的报文，进入连接已建立状态，并发送 ACK = 1表示确认连接建立，ack = y+1 和 seq = x+1 表示对客户端序列的回应；
5. 至此客户端和服务端的连接建立成功；

![](https://gitee.com/Kingshion/imgs/raw/master/imgs/TCP三次握手.jpg)

### 6. 为什么要是三次握手？为什么不是两次？

为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。

客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。

![](https://gitee.com/Kingshion/imgs/raw/master/imgs/两次握手.jpg)

### 7. 四次挥手

1. 客户端主动请求断开连接，发送 FIN = 1 （请求结束标志位），ACK = 1（确认标志位），并带上序列 seq = u （u是上一次数据传输的客户端发送的序列+1），ack = v（v是上一次数据传输过程中服务端发送的序列+1）， 进入终止等待状态一；
2. 服务端收到客户端发送过来的断开连接请求报文，返回给客户端一个收到关闭请求的报文，ACK = 1， seq = v （对客户端请求终止连接的确认）ack = u+1，进入关闭等待状态，通知服务器的应用进程，将还没有发送完成的数据进行发送；
3. 发送完成后，再次发送一个确认关闭的报文给客户端，FIN = 1, ACK = 1, seq = w, ack = u+1（对上次确认收到关闭请求的再次确认），并进入最后确认状态；
4. 客户端收到数据传输完成后的确认关闭报文，向服务器发送一个最后确认关闭的普通报文，ACK = 1，seq = u+1，ack = w+1；并进入时间等待状态；
5. 服务端收到确认关闭后，关闭服务；
6. 客户端超时等待2MSL 后，自动关闭连接；

![](https://gitee.com/Kingshion/imgs/raw/master/imgs/四次挥手.jpg)

##### 为什么要等待 2MSL ？

如果没有时间等待，那么最后一次客户端发送的请求丢失后，服务端会一直误认为客户端没有收到之前服务端发送的确认关闭请求报文，从而导致服务端连接一直开启并不断发送最后确认请求；

![](https://gitee.com/Kingshion/imgs/raw/master/imgs/为什么要时间等待.jpg)

### 8. TCP协议如何来保证传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

对于可靠性，TCP通过以下方式进行保证：

1. 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
2. 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
3. 丢弃重复数据：对于重复数据，能够丢弃重复数据；
4. 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
5. 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
6. 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。



### 9. DDos 攻击

- 客户端向服务端发送请求连接数据包
- 服务端向客户端发送确认数据包
- 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

### 10. DDos 预防

没有彻底根治的办法，除非不使用TCP

- 限制同时打开SYN半链接的数目
- 缩短SYN半链接的Time out 时间
- 关闭不必要的服务

### 11. Get与POST的区别

GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：

1. 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
2. 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；
3. 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为application/x-www-form-urlencoded MIME字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的请求体 中。
4. 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。
5. 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。